#!usr/bin/python
# -*- coding: utf-8 -*-

import numpy as np
import json
import csv
import re
import os

try:
	import tkinter
except ImportError:
	import matplotlib
	matplotlib.use('agg')
	import matplotlib.pyplot as plt
else:
	import matplotlib.pyplot as plt
	import matplotlib.lines as mlines

from Evaluation import GraphDataOrganizer as gdo
from Evaluation import ExperimentManager as em
from Evaluation import StatisticsManager as sm
from MetaScripts import meta
from MetaScripts import global_settings as gs

def get_resultfiles_filenames(directory, algos=None):
	'''
	get all filenames of files that contain experiment result data 
	
	args:
		directory: the directory where the files are
		algos : a list of algorithm-codes. If not None, only the specified algorithms will be considered.
	'''
	all_files_in_dir = os.listdir(directory)
	allfiles = [file for file in all_files_in_dir if ".json" in file]
	if not algos == None:
		files = []
		for algocode in algos:
			files += [file for file in allfiles if "_"+algocode+"_" in file]
	else:
		files = allfiles
	files.sort()
	return files

def make_boxplot(data, setname, graph_set_id, ylabel, savedir=None, filename_suffix=None):
	'''
	create a figure containing the boxplots of a specific dataset.
	This method assumes that the data contains a list of lists, where each sublist corresponds to an algorithm
	and contains the evaluation results of said algorithm.
	All datasets are supposed to belong to a common set of graphs.

	args:
		data : a dict of lists that contains the data to be plotted. each sublist will induce a single boxplot
		setname : the major graph class
		graph_set_id : specifies the subclass
		ylabel : the label for the y-axis
		savedir : if specified, the graph gets saved to this directory.
			if None, the graph gets plotted directly
		filename_suffix : an optional suffix to the autogenerated filename. gets only used if savedir != None.
	'''

	# initialize:
	datadir = "data/eval/random_"+setname+"/results"
	labels = [key for key in data]
	for i in range(len(labels)):
		labelparts = re.split('_', labels[i])
		labels[i] = labelparts[0]
		if not labelparts[1] == "X":
			labels[i] += "_"+labelparts[1]
		if not labelparts[2] == "X":
			labels[i] += "_"+labelparts[2]
	
	#print (labels)
	# create plot:
	fig, ax1 = plt.subplots(figsize=(len(data), 6))
	#fig.canvas.set_window_title('A Boxplot Example')
	fig.subplots_adjust(bottom=0.3)

	ax1.set_xlabel('Algorithm')
	ax1.set_ylabel(ylabel)
	
	if len(data.keys()) == 0:
		print ("Error! No data!")
		return
		
	bp = ax1.boxplot([data[key] for key in data], notch=0, sym='+', vert=1, whis=[5, 95])
	plt.setp(bp['boxes'], color='black')
	ax1.set_xticklabels(labels)
	for tick in ax1.get_xticklabels():
		tick.set_rotation(90)
		
	if savedir == None:
		plt.show()
	elif filename_suffix == None:
		plt.savefig(savedir+"/performance_"+setname+"_"+graph_set_id+"_algo_boxplots.png", dpi=gs.PLT_DPI)
	else:
		plt.savefig(savedir+"/performance_"+setname+"_"+graph_set_id+"_"+filename_suffix+"_algo_boxplots.png", dpi=gs.PLT_DPI)
	plt.close()

def make_boxplot_set(setname, density_class, graph_set_id, axis="OUTPUT", type="ABSOLUTE", savedir=None):
	'''
	Wrapper method for the function above ("make_boxplot"). This method loads data and calls make_boxplots.

	args:
		setname : the major graph class
		graph_set_id : specifies the subclass
		axis : defines which axis of the experiment result data should be plotted 
				("OUTPUT" or "TIME")
		type : defines whether the absolute values or the relative performance should be used for plotting
				("ABSOLUTE" or "RP")
		savedir : specifies a directory where the produced plots are saved.
	'''
	
	if type == "ABSOLUTE":
		# initialize:
		datadir = "data/eval/random_"+setname+"/results"
		all_files_in_dir = os.listdir(datadir)
		files = [file for file in all_files_in_dir if ".json" in file and graph_set_id in file and density_class in file]
		data = {}
		files.sort()
	
		# load data:
		for file in files:
			filepath = datadir+"/"+file
			algo = sm.get_algo_name_from_filename(file)
			data[algo] = sm.load_axis_data_from_file(filepath, axis, True, True)

	elif type == "RP":
		data = sm.compute_relative_performance_distribution_for_subclass(setname, density_class, graph_set_id, axis)
		
	filename_suffix = axis+"_"+type+"_"+density_class
			
	make_boxplot(data, setname, graph_set_id, axis+" ("+type+")", savedir, filename_suffix)

def make_boxplots_allsets(setname, axis="OUTPUT", type="ABSOLUTE"):
	'''
	Uses the method "make_boxplot_set" to construct all boxplots (ie one for each subclass) for a set of experiments
	'''
	basedir = "data/eval/random_"+setname
	graphdir = basedir+"/input"
	resultdir = basedir+"/results"
	outputdir = basedir+"/plots"
	if not os.path.exists(outputdir):
		os.mkdir(outputdir)

	all_graph_set_ids = []
	for filename in os.listdir(graphdir):
		all_graph_set_ids.append(re.split(r'\.',filename)[0])

	for graph_set_id in all_graph_set_ids:
		make_boxplot_set(setname, graph_set_id, axis, type, outputdir)

def make_boxplots_total(setname, density_class=None, algos=None, axis="OUTPUT", type="ABSOLUTE"):
	'''
	Constructs a boxplot-plot of algorithms
	where each boxplot contains all experiment results of the whole major class of graphs
	
	args:
		setname : the major graph class to plot
		density_class : "sparse" or "dense"
		algos : a list of algorithm-codes. If not None, only the specified algorithms will be considered.
	'''
	basedir = "data/eval/random_"+setname
	graphdir = basedir+"/input"
	resultdir = basedir+"/results"
	outputdir = basedir+"/plots"
	if not os.path.exists(outputdir):
		os.mkdir(outputdir)

	data_dict = {}
	
	if type == "ABSOLUTE":
		# initialize:
		files = get_resultfiles_filenames(resultdir, algos)
		
		# load data:
		for file in files:
			filepath = resultdir+"/"+file
			algo = sm.get_algo_name_from_filename(file)
			if algo not in data_dict:
				data_dict[algo] = []
			data_dict[algo] += sm.load_axis_data_from_file(filepath, axis, True, True)

	elif type == "RP":
		for filename in os.listdir(graphdir):
			graph_set_id = re.split(r'\.',filename)[0]
			database = sm.compute_relative_performance_distribution_for_subclass(setname, density_class, graph_set_id, axis, algo_subset=algos)
			for algo_key in database:
				if algos == None or algo_key in algos:
					if algo_key not in data_dict:
						data_dict[algo_key] = []
					data_dict[algo_key] += database[algo_key]
	
	#print ([k for k in data_dict])
	#print (data_dict["MT_X_X"])
	
	filename_suffix = 'total_'+axis+"_"+type
	if not density_class == None:
		filename_suffix += "_"+density_class
	make_boxplot(data_dict, setname, '', ylabel=axis+" ("+type+")", savedir=outputdir, filename_suffix=filename_suffix)
	
def plot_performance_by_algorithm(setname, density_class, graph_set_id="ALL", algos=None, axis="OUTPUT", type="ABSOLUTE", savedir=None, filename_suffix=None):
	'''
	Construct a 2D-line-plot of the algorithms performance,
	where all algorithms are on the x-axis and
	where each graph is a line
	(i.e. same data as the boxplots)
	
	args:
		setname : the major graph class
		density_class : the subclass
		graph_set_id : specifies the subclass, or "ALL"
		algos :  a list of algorithm-codes. If not None, only the specified algorithms will be considered.
		axis : defines which axis of the experiment result data should be plotted 
				("OUTPUT" or "TIME")
		type : defines whether the absolute values or the relative performance should be used for plotting
				("ABSOLUTE" or "RP")
		savedir : specifies a directory where the produced plots are saved.
	'''
	basedir = "data/eval/random_"+setname
	graphdir = basedir+"/input"
	resultdir = basedir+"/results"
	if savedir == None:
		savedir = basedir+"/plots"
	if not os.path.exists(savedir):
		os.mkdir(savedir)
		
	if filename_suffix == None:
		filename_suffix = axis+"_"+type
		
	all_graph_set_ids = []
	if graph_set_id == "ALL":
		graph_set_filename_part = "total"
		for filename in os.listdir(graphdir):
			if density_class in filename:
				all_graph_set_ids.append(re.split(r'\.',filename)[0])
	else:
		graph_set_filename_part = graph_set_id
		all_graph_set_ids.append(graph_set_id)
		
	data = {}
	for graph_set_id in all_graph_set_ids:
		#print (graph_set_id)
		if type == "ABSOLUTE":
			# initialize:
			files = get_resultfiles_filenames(resultdir, algos)
		
			# load data:
			for file in files:
				filepath = resultdir+"/"+file
				algo = sm.get_algo_name_from_filename(file)
				if algo not in data:
					data[algo] = {}
				if graph_set_id not in data[algo]:
					data[algo][graph_set_id] = []
				data[algo][graph_set_id] += np.mean(sm.load_axis_data_from_file(filepath, axis, True, True))
	
		elif type == "RP":
			database = sm.compute_relative_performance_distribution_for_subclass(setname, density_class, graph_set_id, axis, algo_subset=algos)
			for algo in database:
				if algo not in data:
					data[algo] = {}
				if graph_set_id not in data[algo]:
					data[algo][graph_set_id] = []
				data[algo][graph_set_id] += database[algo]
			
	algos = [a for a in data.keys()]
	algo_ids = {}
	for i in range(len(algos)):
		algo_ids[algos[i]] = i
		
	algo_numbers = [algo_ids[a] for a in algos]
			
	linedata = {}
	for graph_set_id in all_graph_set_ids:
		linedata[graph_set_id] = [[-1 for i in range(100)] for a in algos]
	
	for algo in algos:
		for graph_set_id in all_graph_set_ids:
			if graph_set_id in data[algo]:
				linedata[graph_set_id][algo_ids[algo]] = data[algo][graph_set_id]
		
	# create plot:
	fig, ax1 = plt.subplots(figsize=(len(data), len(data)/2))
	fig.subplots_adjust(bottom=0.3)
	
	ax1.set_xlabel("Algorithm")
	ax1.set_ylabel(axis+" ("+type+")")
	
	for graph_set_id in all_graph_set_ids:
		for i in range(len(linedata[graph_set_id][algo_ids[algo]])):
			graph_size = re.split('_', graph_set_id)[1]
			linecolor = gs.PLT_GRAPHSIZE_COLORS[graph_size]
			this_linedata = [linedata[graph_set_id][algo_ids[algo]][i] for algo in algos]
			line = ax1.plot(algo_numbers, this_linedata, label=graph_set_id, linewidth=0.2, color=linecolor)
	
	labels = []
	for i in range(len(algos)):
		labelparts = re.split('_', algos[i])
		labels.append(labelparts[0])
		if not labelparts[1] == "X":
			labels[i] += "_"+labelparts[1]
		if not labelparts[2] == "X":
			labels[i] += "_"+labelparts[2]
			
	ax1.xaxis.set_ticks(range(len(labels)))
	ax1.set_xticklabels(labels)
	for tick in ax1.get_xticklabels():
		tick.set_rotation(90)
	if savedir == None:
		plt.show()
	elif filename_suffix == None:
		plt.savefig(savedir+"/performance_"+graph_set_filename_part+"_algo_line.png", dpi=gs.PLT_DPI)
	else:
		plt.savefig(savedir+"/performance_"+graph_set_filename_part+"_"+filename_suffix+"_algo_line.png", dpi=gs.PLT_DPI)
	plt.close()

def plot_mean_performance_by_density(setname, n, axis="OUTPUT", type="ABSOLUTE", savedir=None):
	'''
	Constructs a 2D-line-plot of the mean performance of algorithms based on the density of graphs.
	'''
	basedir = "data/eval/random_"+setname
	graphdir = basedir+"/input"
	resultdir = basedir+"/results"
	
	all_graph_set_ids_master = {}
	for filename in os.listdir(graphdir):
		if "n"+str(n) in filename:
			graph_set_id = re.split(r'\.',filename)[0]
			graph_set_id_parts = re.split('_', graph_set_id)
			if len(graph_set_id_parts) > 3:
				if graph_set_id_parts[3] not in all_graph_set_ids_master:
					all_graph_set_ids_master[graph_set_id_parts[3]] = []
				all_graph_set_ids_master[graph_set_id_parts[3]].append(graph_set_id)
			else:
				if '' not in all_graph_set_ids_master:
					all_graph_set_ids_master[''] = []
				all_graph_set_ids_master[''].append(graph_set_id)
	
	for graph_set_key in all_graph_set_ids_master:
		files = []
		
		all_graph_set_ids = all_graph_set_ids_master[graph_set_key]
		filename_suffix = ''
		if not graph_set_key == '':
			filename_suffix += graph_set_key+"_"
			
		for graph_set_id in all_graph_set_ids:
			files += [file for file in os.listdir(resultdir) if ".json" in file and graph_set_id in file]
	
		database = {}
		if type == "ABSOLUTE":
			for file in files:
				algo = sm.get_algo_name_from_filename(file)
				evaldata = sm.load_evaldata_from_json(basedir, file)
				avg_m = np.mean([data.m for data in evaldata])
				if axis == "OUTPUT":
					data = [data.output for data in evaldata if data.output >= 0]
				elif axis == "TIME":
					data = [data.running_time for data in evaldata if data.output >= 0]
				if algo not in database:
					database[algo] = {}
				database[algo][avg_m] = np.mean(data)
		
		elif type == "RP":
			for graph_set_id in all_graph_set_ids:
				mrt = sm.compute_mean_relative_performance(setname, graph_set_id, axis)
				examplefile = [file for file in os.listdir(resultdir) if ".json" in file and graph_set_id in file][0]
				evaldata = sm.load_evaldata_from_json(basedir, examplefile)
				avg_m = np.mean([data.m for data in evaldata])
				for algo in mrt:
					if algo not in database:
						database[algo] = {}
					database[algo][avg_m] = mrt[algo]
		
		fig, ax = plt.subplots()
		legenditems = {}
		for algo in database:
			basealgo = re.split('_', algo)[0]
			linestyle = '-'
			if "_B" in algo:
				if "_R" in algo:
					linestyle = '-.'
				else:
					linestyle = ':'
			elif "_R" in algo:
				linestyle = '--'
			
			m = sorted([avg_m for avg_m in database[algo]])
			data = [database[algo][avg_m] for avg_m in m]
			line = ax.plot(m, data, label=algo, linewidth=0.5, linestyle=linestyle, color=gs.PLT_ALGO_COLORS[basealgo])
			if basealgo not in legenditems:
				legenditems[basealgo] = mlines.Line2D([],[], color=gs.PLT_ALGO_COLORS[basealgo], label=basealgo) 
		
		ax.set_xlabel('number of edges (i.e. density)')
		ax.set_ylabel(axis+" ("+type+")")
		legend = ax.legend(handles=[legenditems[a] for a in legenditems], bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0.)
		
		if savedir == None:
			plt.show()
		else:
			filename_suffix += axis+"_"+type
			filename = savedir+"/performance_"+setname+"_n"+str(n)+"_density_"+filename_suffix+".png"
			#print (filename)
			plt.savefig(filename, dpi=gs.PLT_DPI, bbox_extra_artists=(legend,), bbox_inches='tight')
		plt.close()
		
def make_performance_plots_all(setname, axis="OUTPUT", type="ABSOLUTE"):
	basedir = "data/eval/random_"+setname
	outputdir = basedir+"/plots"
	if not os.path.exists(outputdir):
		os.mkdir(outputdir)

	for n in [20, 40, 60, 80, 100]:
		plot_mean_performance_by_density(setname, n, axis, type, savedir=outputdir)

def performance_plot_analyze_reduction(setname, density_class, algocodes=None, n=100, axis="OUTPUT"):
	'''
	print (setname)
	print (density_class)
	print (n)
	print (axis)
	'''
	if algocodes == None:
		algocodes = ["EG", "SMS", "CMT", "EGPLUS", "LexM", "MCSM"]
		
	basedir = "data/eval/random_"+setname
	graphdir = basedir+"/input"
	resultdir = basedir+"/results"
	outputdir = basedir+"/plots"
	if not os.path.exists(outputdir):
		os.mkdir(outputdir)
		
	filenames_reduced = {}
	filenames_basic = {}
	for filename in os.listdir(resultdir):
		if density_class in filename and "n"+str(n) in filename and not "_R" in filename and ".json" in filename:
			filenameparts = re.split('_', filename)
			this_n = -1
			this_p = -1
			algo = filenameparts[2]
			if algo in algocodes:
				if algo not in filenames_basic:
					filenames_basic[algo] = {}
					filenames_reduced[algo] = {}
				for part in filenameparts:
					if part[0] == "n":
						this_n = int(part[1:])
					elif part[0] == "p":
						this_p = float(re.split('\.',part)[0][2:])/100
					elif part[:4] == "relm":
						this_p = float(re.split('\.',part)[0][4:])/10
						if this_p > 10:
							this_p /= 10
							
				if "_B_" in filename:
					if this_n not in filenames_basic[algo]:
						filenames_basic[algo][this_n] = {}
					if this_p not in filenames_basic[algo][this_n]:
						filenames_basic[algo][this_n][this_p] = []
					filenames_basic[algo][this_n][this_p].append(filename)
				else:
					if this_n not in filenames_reduced[algo]:
						filenames_reduced[algo][this_n] = {}
					if this_p not in filenames_reduced[algo][this_n]:
						filenames_reduced[algo][this_n][this_p] = []
					filenames_reduced[algo][this_n][this_p].append(filename)
	
	database_basic = {}
	database_reduced = {}
	legenditems = {}
	
	fig, ax = plt.subplots()
	
	for algo in filenames_basic:
		database_basic[algo] = {}
		if n in filenames_basic[algo]:
			for p in filenames_basic[algo][n]:
				database_basic[algo][p] = []
				for file in filenames_basic[algo][n][p]:
					evaldata = sm.load_evaldata_from_json(basedir, file)
					if axis == "OUTPUT":
						database_basic[algo][p].append([data.output for data in evaldata if data.output >= 0])
					elif axis == "TIME":
						database_basic[algo][p].append([data.running_time for data in evaldata if data.output >= 0])
		legenditems[algo+"_X"] = mlines.Line2D([],[], linestyle='--', color=gs.PLT_ALGO_COLORS[algo], label=algo+" (basic)") 
		linedata_b = [np.mean(database_basic[algo][p][0]) for p in database_basic[algo]]
		xvalues_b = [float(p) for p in database_basic[algo]]
		linecolor = gs.PLT_ALGO_COLORS[algo]
		line = ax.plot(xvalues_b, linedata_b, label=str(n), linewidth=1, linestyle='--', color=linecolor)
		
					
	for algo in filenames_reduced:
		database_reduced[algo] = {}
		if n in filenames_reduced[algo]:
			for p in filenames_reduced[algo][n]:
				database_reduced[algo][p] = []
				for file in filenames_reduced[algo][n][p]:
					evaldata = sm.load_evaldata_from_json(basedir, file)
					if axis == "OUTPUT":
						database_reduced[algo][p].append([data.output for data in evaldata if data.output >= 0])
					elif axis == "TIME":
						database_reduced[algo][p].append([data.running_time for data in evaldata if data.output >= 0])
		legenditems[algo+"_B"] = mlines.Line2D([],[], linestyle='-', color=gs.PLT_ALGO_COLORS[algo], label=algo+" (reduced)") 
		linedata_r = [np.mean(database_reduced[algo][p][0]) for p in database_reduced[algo]]
		xvalues_r = [float(p) for p in database_reduced[algo]]
		linecolor = gs.PLT_ALGO_COLORS[algo]
		line = ax.plot(xvalues_r, linedata_r, label=str(n), linewidth=1, linestyle='-', color=linecolor)
	
	xlabel = "density"
	if density_class == "dense":
		xlabel += " (edge-probability p)"
	else:
		xlabel += " (relative amount of edges (m/n))"
	ax.set_xlabel(xlabel)
	if axis == "TIME":
		ax.set_ylabel("Average runtime (in sec.)")
	else:
		ax.set_ylabel("Average size of fill-in")
		
	ax.xaxis.set_ticks(xvalues_r)
	#ax.set_xticklabels(xvalues_r)
	
	legend = ax.legend(handles=[legenditems[a] for a in legenditems], bbox_to_anchor=(1.05, 1), loc=2, borderaxespad=0.)
	
	filename = outputdir+"/cmp_reduction_"+setname+"_"+density_class+"_"+axis+"_n"+str(n)+".png"
	plt.savefig(filename, dpi=gs.PLT_DPI, bbox_extra_artists=(legend,), bbox_inches='tight')
	plt.close()
	